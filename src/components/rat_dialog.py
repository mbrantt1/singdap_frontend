from src.components.generic_form_dialog import GenericFormDialog
from PySide6.QtWidgets import QComboBox
from pathlib import Path
import json

class RatDialog(GenericFormDialog):
    def __init__(self, parent=None, rat_id=None, **kwargs):
        # Resolve config relative to THIS file or project root
        base_dir = Path(__file__).resolve().parent.parent.parent # singdap_frontend/
        self.config_ia_path = base_dir / "src" / "config" / "formularios" / "rat_ia.json"
        self.config_institucional_path = base_dir / "src" / "config" / "formularios" / "rat_institucional.json"
        self.config_simplificado_path = base_dir / "src" / "config" / "formularios" / "rat_simplificado.json"
        
        config_path = base_dir / "src" / "config" / "formularios" / "rat.json"
        
        # GridView passes arguments based on "campo_id" in grid config.
        # For RAT, likely "rat_id" or "id".
        # We accept rat_id explicitly, but check kwargs just in case.
        target_id = rat_id
        if target_id is None:
             target_id = kwargs.get("id")
        
        # Track current extension
        self._current_extension = None
        
        super().__init__(str(config_path), parent=parent, record_id=target_id)
        
        # --- Logic for Dynamic Expansion ---
        # RAT_BASE triggers extension if 'tipo_tratamiento' matches specific IDs
        if "tipo_tratamiento" in self.inputs:
            combo = self.inputs["tipo_tratamiento"]
            if isinstance(combo, QComboBox):
                combo.currentIndexChanged.connect(self._check_type_transition)
                
                # Check initial state happens in _on_record_data or manual check if New
        
    def _check_type_transition(self):
        combo = self.inputs.get("tipo_tratamiento")
        if not combo: return
        
        val = combo.currentData()
        
        target_config = None
        target_name = None
        
        if val == "iniciativa_ia":
            target_config = self.config_ia_path
            target_name = "ia"
        elif val == "proceso_institucional":
            target_config = self.config_institucional_path
            target_name = "institucional"
        elif val in ["rat_simplificado", "gestion_rrhh", "sistema", "proyecto", "nomina", "otra"]:
            target_config = self.config_simplificado_path
            target_name = "simplificado"
            
        # Transition Logic
        if target_name != self._current_extension:
            # 1. Shrink previous extension if any
            if self._current_extension:
                self._shrink_form()
                
            # 2. Expand new extension if any
            if target_config:
                self._expand_form(target_config)
                self._current_extension = target_name
            else:
                self._current_extension = None

    def _expand_form(self, config_path):
        # Load Extension Config
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                ext_config = json.load(f)
        except Exception as e:
            print(f"Error loading extension config: {e}")
            return

        # New sections are those from index 2 onwards (Extending Base which has 2)
        # Assumes extension config is generated by appending to base.
        new_sections = ext_config.get("sections", [])[2:]
        
        if not new_sections: return

        start_index = len(self.config["sections"])
        
        # Update Config
        self.config["sections"].extend(new_sections)
        
        # Build UI for new sections
        for i, section in enumerate(new_sections):
            abs_index = start_index + i
            
            # 1. Build Widget
            # This registers inputs into self.inputs automatically
            content_widget = self._build_section_form(section)
            
            # 2. Add to Sidebar
            self.sidebar.add_step(section["title"])
            
            # 3. Add to Stack
            page = self._wrap_step_content(
                content_widget,
                section["title"],
                section.get("description", ""),
                abs_index,
                len(self.config["sections"]) # This total is dynamic now
            )
            self.stack.addWidget(page)
            
            # 4. Initialize async combos for new fields if any
            self._load_new_combos(section)

        # Update footer buttons for previous last page
        prev_last_page_idx = start_index - 1
        if prev_last_page_idx >= 0:
             self._update_footer_to_next(prev_last_page_idx)

        # Trigger validation to update counts
        self._validate_steps_progress()

    def _shrink_form(self):
        # Remove sections from index 2 onwards
        # Base has 2 sections.
        current_len = len(self.config["sections"])
        target_len = 2 
        
        if current_len <= target_len: return
        
        # Remove from end
        while len(self.config["sections"]) > target_len:
            # Get processed section (last one)
            section = self.config["sections"].pop()
            
            # 1. Unregister inputs
            for field in section.get("fields", []):
                key = field["key"]
                if key in self.inputs:
                    del self.inputs[key]
                if key in self.dependencies:
                    del self.dependencies[key]
                if key in self.dependency_configs:
                    del self.dependency_configs[key]
            
            # 2. Remove from Sidebar
            self.sidebar.remove_last_step()
            
            # 3. Remove from Stack
            last_widget = self.stack.widget(self.stack.count() - 1)
            self.stack.removeWidget(last_widget)
            last_widget.deleteLater()
            
        # Update footer of the new last page (index 1) to be "Guardar"
        self._update_footer_to_save(target_len - 1)
            
        self._validate_steps_progress()

    def _load_new_combos(self, section):
        # Similar to _init_async_load but for specific section
        for field in section.get("fields", []):
            if field.get("type") == "combo" and field.get("source") and not field.get("depends_on"):
                key = field["key"]
                widget = self.inputs.get(key)
                if widget and isinstance(widget, QComboBox): # Check type
                    endpoint = field["source"]
                    cache_key = field.get("cache_key", f"cache_{key}")
                    self._start_combo_loader(widget, endpoint, cache_key)
                    
    def _update_footer_to_next(self, index):
        # Access the page widget
        page = self.stack.widget(index)
        if not page: return
        
        # Page layout: [Header, Line, Scroll, Footer(HBox)]
        # We need to find the footer layout. It's the last item in the main VBox.
        layout = page.layout()
        if not layout: return
        
        footer_item = layout.itemAt(layout.count() - 1)
        if not footer_item: return
        footer_layout = footer_item.layout()
        if not footer_layout: return
        
        # Identify "Guardar" button. It should be the last widget.
        # But we want to REPLACE "Guardar" with "Siguiente"
        
        # Clear footer
        self._clear_layout(footer_layout)
        
        # Re-add buttons
        # Prev
        if index > 0:
            from PySide6.QtWidgets import QPushButton
            prev_btn = QPushButton("Anterior")
            prev_btn.setObjectName("secondaryButton")
            prev_btn.clicked.connect(self.sidebar.prev_step)
            footer_layout.addWidget(prev_btn)
            
        footer_layout.addStretch()
        
        # Next (since we expanded)
        from PySide6.QtWidgets import QPushButton
        next_btn = QPushButton("Siguiente")
        next_btn.setObjectName("primaryButton")
        next_btn.clicked.connect(self.sidebar.next_step)
        footer_layout.addWidget(next_btn)
        
    def _update_footer_to_save(self, index):
        page = self.stack.widget(index)
        if not page: return
        
        layout = page.layout()
        if not layout: return
        
        footer_item = layout.itemAt(layout.count() - 1)
        if not footer_item: return
        footer_layout = footer_item.layout()
        if not footer_layout: return
        
        self._clear_layout(footer_layout)
        
        if index > 0:
            from PySide6.QtWidgets import QPushButton
            prev_btn = QPushButton("Anterior")
            prev_btn.setObjectName("secondaryButton")
            prev_btn.clicked.connect(self.sidebar.prev_step)
            footer_layout.addWidget(prev_btn)
            
        footer_layout.addStretch()
        
        from PySide6.QtWidgets import QPushButton
        save_btn = QPushButton("Guardar")
        save_btn.setObjectName("primaryButton")
        save_btn.clicked.connect(self._submit)
        footer_layout.addWidget(save_btn)

    def _clear_layout(self, layout):
        while layout.count():
            child = layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
            elif child.layout():
                self._clear_layout(child.layout())
        
    def _on_record_data(self, data):
        # Override to check for IA type before setting values
        # Because we need the fields to exist BEFORE setting values!
        if data:
            t_trat = data.get("tipo_tratamiento")
            # Handle if it comes as dict or ID? 
            # Usually generic form sets simple values. If combo_static, it stores ID.
            # If we changed to combo_static, it's just ID string.
            val = t_trat
            if isinstance(t_trat, dict):
                 val = t_trat.get("id")
            
            if val == "iniciativa_ia":
                 # Force expansion
                 # We need to manually set the combo first?
                 # No, _expand_form depends on nothing but method call.
                 # But we should rely on the input's signal? 
                 # _try_set_values sets the input text/data.
                 # Does setValue trigger 'currentIndexChanged'? 
                 # programmatic change -> usually NO in Qt unless explicitly set?
                 # Actually setCurrentIndex DOES trigger signal `currentIndexChanged`.
                 pass
        
        super()._on_record_data(data)
